// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"
	"time"

	"github.com/pivotal-cf/cf-redis-broker/redis/client"
)

type FakeClient struct {
	DisconnectStub        func() error
	disconnectMutex       sync.RWMutex
	disconnectArgsForCall []struct{}
	disconnectReturns     struct {
		result1 error
	}
	disconnectReturnsOnCall map[int]struct {
		result1 error
	}
	WaitUntilRedisNotLoadingStub        func(timeoutMilliseconds int) error
	waitUntilRedisNotLoadingMutex       sync.RWMutex
	waitUntilRedisNotLoadingArgsForCall []struct {
		timeoutMilliseconds int
	}
	waitUntilRedisNotLoadingReturns struct {
		result1 error
	}
	waitUntilRedisNotLoadingReturnsOnCall map[int]struct {
		result1 error
	}
	EnableAOFStub        func() error
	enableAOFMutex       sync.RWMutex
	enableAOFArgsForCall []struct{}
	enableAOFReturns     struct {
		result1 error
	}
	enableAOFReturnsOnCall map[int]struct {
		result1 error
	}
	LastRDBSaveTimeStub        func() (int64, error)
	lastRDBSaveTimeMutex       sync.RWMutex
	lastRDBSaveTimeArgsForCall []struct{}
	lastRDBSaveTimeReturns     struct {
		result1 int64
		result2 error
	}
	lastRDBSaveTimeReturnsOnCall map[int]struct {
		result1 int64
		result2 error
	}
	InfoStub        func() (map[string]string, error)
	infoMutex       sync.RWMutex
	infoArgsForCall []struct{}
	infoReturns     struct {
		result1 map[string]string
		result2 error
	}
	infoReturnsOnCall map[int]struct {
		result1 map[string]string
		result2 error
	}
	InfoFieldStub        func(fieldName string) (string, error)
	infoFieldMutex       sync.RWMutex
	infoFieldArgsForCall []struct {
		fieldName string
	}
	infoFieldReturns struct {
		result1 string
		result2 error
	}
	infoFieldReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GlobalKeyCountStub        func() (int, error)
	globalKeyCountMutex       sync.RWMutex
	globalKeyCountArgsForCall []struct{}
	globalKeyCountReturns     struct {
		result1 int
		result2 error
	}
	globalKeyCountReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	GetConfigStub        func(key string) (string, error)
	getConfigMutex       sync.RWMutex
	getConfigArgsForCall []struct {
		key string
	}
	getConfigReturns struct {
		result1 string
		result2 error
	}
	getConfigReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	RDBPathStub        func() (string, error)
	rDBPathMutex       sync.RWMutex
	rDBPathArgsForCall []struct{}
	rDBPathReturns     struct {
		result1 string
		result2 error
	}
	rDBPathReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	AddressStub        func() string
	addressMutex       sync.RWMutex
	addressArgsForCall []struct{}
	addressReturns     struct {
		result1 string
	}
	addressReturnsOnCall map[int]struct {
		result1 string
	}
	WaitForNewSaveSinceStub        func(lastSaveTime int64, timeout time.Duration) error
	waitForNewSaveSinceMutex       sync.RWMutex
	waitForNewSaveSinceArgsForCall []struct {
		lastSaveTime int64
		timeout      time.Duration
	}
	waitForNewSaveSinceReturns struct {
		result1 error
	}
	waitForNewSaveSinceReturnsOnCall map[int]struct {
		result1 error
	}
	RunBGSaveStub        func() error
	runBGSaveMutex       sync.RWMutex
	runBGSaveArgsForCall []struct{}
	runBGSaveReturns     struct {
		result1 error
	}
	runBGSaveReturnsOnCall map[int]struct {
		result1 error
	}
	PingStub        func() error
	pingMutex       sync.RWMutex
	pingArgsForCall []struct{}
	pingReturns     struct {
		result1 error
	}
	pingReturnsOnCall map[int]struct {
		result1 error
	}
	ExecStub        func(command string, args ...interface{}) (interface{}, error)
	execMutex       sync.RWMutex
	execArgsForCall []struct {
		command string
		args    []interface{}
	}
	execReturns struct {
		result1 interface{}
		result2 error
	}
	execReturnsOnCall map[int]struct {
		result1 interface{}
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) Disconnect() error {
	fake.disconnectMutex.Lock()
	ret, specificReturn := fake.disconnectReturnsOnCall[len(fake.disconnectArgsForCall)]
	fake.disconnectArgsForCall = append(fake.disconnectArgsForCall, struct{}{})
	fake.recordInvocation("Disconnect", []interface{}{})
	fake.disconnectMutex.Unlock()
	if fake.DisconnectStub != nil {
		return fake.DisconnectStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.disconnectReturns.result1
}

func (fake *FakeClient) DisconnectCallCount() int {
	fake.disconnectMutex.RLock()
	defer fake.disconnectMutex.RUnlock()
	return len(fake.disconnectArgsForCall)
}

func (fake *FakeClient) DisconnectReturns(result1 error) {
	fake.DisconnectStub = nil
	fake.disconnectReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DisconnectReturnsOnCall(i int, result1 error) {
	fake.DisconnectStub = nil
	if fake.disconnectReturnsOnCall == nil {
		fake.disconnectReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.disconnectReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WaitUntilRedisNotLoading(timeoutMilliseconds int) error {
	fake.waitUntilRedisNotLoadingMutex.Lock()
	ret, specificReturn := fake.waitUntilRedisNotLoadingReturnsOnCall[len(fake.waitUntilRedisNotLoadingArgsForCall)]
	fake.waitUntilRedisNotLoadingArgsForCall = append(fake.waitUntilRedisNotLoadingArgsForCall, struct {
		timeoutMilliseconds int
	}{timeoutMilliseconds})
	fake.recordInvocation("WaitUntilRedisNotLoading", []interface{}{timeoutMilliseconds})
	fake.waitUntilRedisNotLoadingMutex.Unlock()
	if fake.WaitUntilRedisNotLoadingStub != nil {
		return fake.WaitUntilRedisNotLoadingStub(timeoutMilliseconds)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.waitUntilRedisNotLoadingReturns.result1
}

func (fake *FakeClient) WaitUntilRedisNotLoadingCallCount() int {
	fake.waitUntilRedisNotLoadingMutex.RLock()
	defer fake.waitUntilRedisNotLoadingMutex.RUnlock()
	return len(fake.waitUntilRedisNotLoadingArgsForCall)
}

func (fake *FakeClient) WaitUntilRedisNotLoadingArgsForCall(i int) int {
	fake.waitUntilRedisNotLoadingMutex.RLock()
	defer fake.waitUntilRedisNotLoadingMutex.RUnlock()
	return fake.waitUntilRedisNotLoadingArgsForCall[i].timeoutMilliseconds
}

func (fake *FakeClient) WaitUntilRedisNotLoadingReturns(result1 error) {
	fake.WaitUntilRedisNotLoadingStub = nil
	fake.waitUntilRedisNotLoadingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WaitUntilRedisNotLoadingReturnsOnCall(i int, result1 error) {
	fake.WaitUntilRedisNotLoadingStub = nil
	if fake.waitUntilRedisNotLoadingReturnsOnCall == nil {
		fake.waitUntilRedisNotLoadingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.waitUntilRedisNotLoadingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) EnableAOF() error {
	fake.enableAOFMutex.Lock()
	ret, specificReturn := fake.enableAOFReturnsOnCall[len(fake.enableAOFArgsForCall)]
	fake.enableAOFArgsForCall = append(fake.enableAOFArgsForCall, struct{}{})
	fake.recordInvocation("EnableAOF", []interface{}{})
	fake.enableAOFMutex.Unlock()
	if fake.EnableAOFStub != nil {
		return fake.EnableAOFStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.enableAOFReturns.result1
}

func (fake *FakeClient) EnableAOFCallCount() int {
	fake.enableAOFMutex.RLock()
	defer fake.enableAOFMutex.RUnlock()
	return len(fake.enableAOFArgsForCall)
}

func (fake *FakeClient) EnableAOFReturns(result1 error) {
	fake.EnableAOFStub = nil
	fake.enableAOFReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) EnableAOFReturnsOnCall(i int, result1 error) {
	fake.EnableAOFStub = nil
	if fake.enableAOFReturnsOnCall == nil {
		fake.enableAOFReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.enableAOFReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) LastRDBSaveTime() (int64, error) {
	fake.lastRDBSaveTimeMutex.Lock()
	ret, specificReturn := fake.lastRDBSaveTimeReturnsOnCall[len(fake.lastRDBSaveTimeArgsForCall)]
	fake.lastRDBSaveTimeArgsForCall = append(fake.lastRDBSaveTimeArgsForCall, struct{}{})
	fake.recordInvocation("LastRDBSaveTime", []interface{}{})
	fake.lastRDBSaveTimeMutex.Unlock()
	if fake.LastRDBSaveTimeStub != nil {
		return fake.LastRDBSaveTimeStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.lastRDBSaveTimeReturns.result1, fake.lastRDBSaveTimeReturns.result2
}

func (fake *FakeClient) LastRDBSaveTimeCallCount() int {
	fake.lastRDBSaveTimeMutex.RLock()
	defer fake.lastRDBSaveTimeMutex.RUnlock()
	return len(fake.lastRDBSaveTimeArgsForCall)
}

func (fake *FakeClient) LastRDBSaveTimeReturns(result1 int64, result2 error) {
	fake.LastRDBSaveTimeStub = nil
	fake.lastRDBSaveTimeReturns = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) LastRDBSaveTimeReturnsOnCall(i int, result1 int64, result2 error) {
	fake.LastRDBSaveTimeStub = nil
	if fake.lastRDBSaveTimeReturnsOnCall == nil {
		fake.lastRDBSaveTimeReturnsOnCall = make(map[int]struct {
			result1 int64
			result2 error
		})
	}
	fake.lastRDBSaveTimeReturnsOnCall[i] = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Info() (map[string]string, error) {
	fake.infoMutex.Lock()
	ret, specificReturn := fake.infoReturnsOnCall[len(fake.infoArgsForCall)]
	fake.infoArgsForCall = append(fake.infoArgsForCall, struct{}{})
	fake.recordInvocation("Info", []interface{}{})
	fake.infoMutex.Unlock()
	if fake.InfoStub != nil {
		return fake.InfoStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.infoReturns.result1, fake.infoReturns.result2
}

func (fake *FakeClient) InfoCallCount() int {
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	return len(fake.infoArgsForCall)
}

func (fake *FakeClient) InfoReturns(result1 map[string]string, result2 error) {
	fake.InfoStub = nil
	fake.infoReturns = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) InfoReturnsOnCall(i int, result1 map[string]string, result2 error) {
	fake.InfoStub = nil
	if fake.infoReturnsOnCall == nil {
		fake.infoReturnsOnCall = make(map[int]struct {
			result1 map[string]string
			result2 error
		})
	}
	fake.infoReturnsOnCall[i] = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) InfoField(fieldName string) (string, error) {
	fake.infoFieldMutex.Lock()
	ret, specificReturn := fake.infoFieldReturnsOnCall[len(fake.infoFieldArgsForCall)]
	fake.infoFieldArgsForCall = append(fake.infoFieldArgsForCall, struct {
		fieldName string
	}{fieldName})
	fake.recordInvocation("InfoField", []interface{}{fieldName})
	fake.infoFieldMutex.Unlock()
	if fake.InfoFieldStub != nil {
		return fake.InfoFieldStub(fieldName)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.infoFieldReturns.result1, fake.infoFieldReturns.result2
}

func (fake *FakeClient) InfoFieldCallCount() int {
	fake.infoFieldMutex.RLock()
	defer fake.infoFieldMutex.RUnlock()
	return len(fake.infoFieldArgsForCall)
}

func (fake *FakeClient) InfoFieldArgsForCall(i int) string {
	fake.infoFieldMutex.RLock()
	defer fake.infoFieldMutex.RUnlock()
	return fake.infoFieldArgsForCall[i].fieldName
}

func (fake *FakeClient) InfoFieldReturns(result1 string, result2 error) {
	fake.InfoFieldStub = nil
	fake.infoFieldReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) InfoFieldReturnsOnCall(i int, result1 string, result2 error) {
	fake.InfoFieldStub = nil
	if fake.infoFieldReturnsOnCall == nil {
		fake.infoFieldReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.infoFieldReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GlobalKeyCount() (int, error) {
	fake.globalKeyCountMutex.Lock()
	ret, specificReturn := fake.globalKeyCountReturnsOnCall[len(fake.globalKeyCountArgsForCall)]
	fake.globalKeyCountArgsForCall = append(fake.globalKeyCountArgsForCall, struct{}{})
	fake.recordInvocation("GlobalKeyCount", []interface{}{})
	fake.globalKeyCountMutex.Unlock()
	if fake.GlobalKeyCountStub != nil {
		return fake.GlobalKeyCountStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.globalKeyCountReturns.result1, fake.globalKeyCountReturns.result2
}

func (fake *FakeClient) GlobalKeyCountCallCount() int {
	fake.globalKeyCountMutex.RLock()
	defer fake.globalKeyCountMutex.RUnlock()
	return len(fake.globalKeyCountArgsForCall)
}

func (fake *FakeClient) GlobalKeyCountReturns(result1 int, result2 error) {
	fake.GlobalKeyCountStub = nil
	fake.globalKeyCountReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GlobalKeyCountReturnsOnCall(i int, result1 int, result2 error) {
	fake.GlobalKeyCountStub = nil
	if fake.globalKeyCountReturnsOnCall == nil {
		fake.globalKeyCountReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.globalKeyCountReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetConfig(key string) (string, error) {
	fake.getConfigMutex.Lock()
	ret, specificReturn := fake.getConfigReturnsOnCall[len(fake.getConfigArgsForCall)]
	fake.getConfigArgsForCall = append(fake.getConfigArgsForCall, struct {
		key string
	}{key})
	fake.recordInvocation("GetConfig", []interface{}{key})
	fake.getConfigMutex.Unlock()
	if fake.GetConfigStub != nil {
		return fake.GetConfigStub(key)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getConfigReturns.result1, fake.getConfigReturns.result2
}

func (fake *FakeClient) GetConfigCallCount() int {
	fake.getConfigMutex.RLock()
	defer fake.getConfigMutex.RUnlock()
	return len(fake.getConfigArgsForCall)
}

func (fake *FakeClient) GetConfigArgsForCall(i int) string {
	fake.getConfigMutex.RLock()
	defer fake.getConfigMutex.RUnlock()
	return fake.getConfigArgsForCall[i].key
}

func (fake *FakeClient) GetConfigReturns(result1 string, result2 error) {
	fake.GetConfigStub = nil
	fake.getConfigReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetConfigReturnsOnCall(i int, result1 string, result2 error) {
	fake.GetConfigStub = nil
	if fake.getConfigReturnsOnCall == nil {
		fake.getConfigReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getConfigReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) RDBPath() (string, error) {
	fake.rDBPathMutex.Lock()
	ret, specificReturn := fake.rDBPathReturnsOnCall[len(fake.rDBPathArgsForCall)]
	fake.rDBPathArgsForCall = append(fake.rDBPathArgsForCall, struct{}{})
	fake.recordInvocation("RDBPath", []interface{}{})
	fake.rDBPathMutex.Unlock()
	if fake.RDBPathStub != nil {
		return fake.RDBPathStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.rDBPathReturns.result1, fake.rDBPathReturns.result2
}

func (fake *FakeClient) RDBPathCallCount() int {
	fake.rDBPathMutex.RLock()
	defer fake.rDBPathMutex.RUnlock()
	return len(fake.rDBPathArgsForCall)
}

func (fake *FakeClient) RDBPathReturns(result1 string, result2 error) {
	fake.RDBPathStub = nil
	fake.rDBPathReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) RDBPathReturnsOnCall(i int, result1 string, result2 error) {
	fake.RDBPathStub = nil
	if fake.rDBPathReturnsOnCall == nil {
		fake.rDBPathReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.rDBPathReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Address() string {
	fake.addressMutex.Lock()
	ret, specificReturn := fake.addressReturnsOnCall[len(fake.addressArgsForCall)]
	fake.addressArgsForCall = append(fake.addressArgsForCall, struct{}{})
	fake.recordInvocation("Address", []interface{}{})
	fake.addressMutex.Unlock()
	if fake.AddressStub != nil {
		return fake.AddressStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.addressReturns.result1
}

func (fake *FakeClient) AddressCallCount() int {
	fake.addressMutex.RLock()
	defer fake.addressMutex.RUnlock()
	return len(fake.addressArgsForCall)
}

func (fake *FakeClient) AddressReturns(result1 string) {
	fake.AddressStub = nil
	fake.addressReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeClient) AddressReturnsOnCall(i int, result1 string) {
	fake.AddressStub = nil
	if fake.addressReturnsOnCall == nil {
		fake.addressReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.addressReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeClient) WaitForNewSaveSince(lastSaveTime int64, timeout time.Duration) error {
	fake.waitForNewSaveSinceMutex.Lock()
	ret, specificReturn := fake.waitForNewSaveSinceReturnsOnCall[len(fake.waitForNewSaveSinceArgsForCall)]
	fake.waitForNewSaveSinceArgsForCall = append(fake.waitForNewSaveSinceArgsForCall, struct {
		lastSaveTime int64
		timeout      time.Duration
	}{lastSaveTime, timeout})
	fake.recordInvocation("WaitForNewSaveSince", []interface{}{lastSaveTime, timeout})
	fake.waitForNewSaveSinceMutex.Unlock()
	if fake.WaitForNewSaveSinceStub != nil {
		return fake.WaitForNewSaveSinceStub(lastSaveTime, timeout)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.waitForNewSaveSinceReturns.result1
}

func (fake *FakeClient) WaitForNewSaveSinceCallCount() int {
	fake.waitForNewSaveSinceMutex.RLock()
	defer fake.waitForNewSaveSinceMutex.RUnlock()
	return len(fake.waitForNewSaveSinceArgsForCall)
}

func (fake *FakeClient) WaitForNewSaveSinceArgsForCall(i int) (int64, time.Duration) {
	fake.waitForNewSaveSinceMutex.RLock()
	defer fake.waitForNewSaveSinceMutex.RUnlock()
	return fake.waitForNewSaveSinceArgsForCall[i].lastSaveTime, fake.waitForNewSaveSinceArgsForCall[i].timeout
}

func (fake *FakeClient) WaitForNewSaveSinceReturns(result1 error) {
	fake.WaitForNewSaveSinceStub = nil
	fake.waitForNewSaveSinceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WaitForNewSaveSinceReturnsOnCall(i int, result1 error) {
	fake.WaitForNewSaveSinceStub = nil
	if fake.waitForNewSaveSinceReturnsOnCall == nil {
		fake.waitForNewSaveSinceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.waitForNewSaveSinceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) RunBGSave() error {
	fake.runBGSaveMutex.Lock()
	ret, specificReturn := fake.runBGSaveReturnsOnCall[len(fake.runBGSaveArgsForCall)]
	fake.runBGSaveArgsForCall = append(fake.runBGSaveArgsForCall, struct{}{})
	fake.recordInvocation("RunBGSave", []interface{}{})
	fake.runBGSaveMutex.Unlock()
	if fake.RunBGSaveStub != nil {
		return fake.RunBGSaveStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.runBGSaveReturns.result1
}

func (fake *FakeClient) RunBGSaveCallCount() int {
	fake.runBGSaveMutex.RLock()
	defer fake.runBGSaveMutex.RUnlock()
	return len(fake.runBGSaveArgsForCall)
}

func (fake *FakeClient) RunBGSaveReturns(result1 error) {
	fake.RunBGSaveStub = nil
	fake.runBGSaveReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) RunBGSaveReturnsOnCall(i int, result1 error) {
	fake.RunBGSaveStub = nil
	if fake.runBGSaveReturnsOnCall == nil {
		fake.runBGSaveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.runBGSaveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) Ping() error {
	fake.pingMutex.Lock()
	ret, specificReturn := fake.pingReturnsOnCall[len(fake.pingArgsForCall)]
	fake.pingArgsForCall = append(fake.pingArgsForCall, struct{}{})
	fake.recordInvocation("Ping", []interface{}{})
	fake.pingMutex.Unlock()
	if fake.PingStub != nil {
		return fake.PingStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.pingReturns.result1
}

func (fake *FakeClient) PingCallCount() int {
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	return len(fake.pingArgsForCall)
}

func (fake *FakeClient) PingReturns(result1 error) {
	fake.PingStub = nil
	fake.pingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PingReturnsOnCall(i int, result1 error) {
	fake.PingStub = nil
	if fake.pingReturnsOnCall == nil {
		fake.pingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) Exec(command string, args ...interface{}) (interface{}, error) {
	fake.execMutex.Lock()
	ret, specificReturn := fake.execReturnsOnCall[len(fake.execArgsForCall)]
	fake.execArgsForCall = append(fake.execArgsForCall, struct {
		command string
		args    []interface{}
	}{command, args})
	fake.recordInvocation("Exec", []interface{}{command, args})
	fake.execMutex.Unlock()
	if fake.ExecStub != nil {
		return fake.ExecStub(command, args...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.execReturns.result1, fake.execReturns.result2
}

func (fake *FakeClient) ExecCallCount() int {
	fake.execMutex.RLock()
	defer fake.execMutex.RUnlock()
	return len(fake.execArgsForCall)
}

func (fake *FakeClient) ExecArgsForCall(i int) (string, []interface{}) {
	fake.execMutex.RLock()
	defer fake.execMutex.RUnlock()
	return fake.execArgsForCall[i].command, fake.execArgsForCall[i].args
}

func (fake *FakeClient) ExecReturns(result1 interface{}, result2 error) {
	fake.ExecStub = nil
	fake.execReturns = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ExecReturnsOnCall(i int, result1 interface{}, result2 error) {
	fake.ExecStub = nil
	if fake.execReturnsOnCall == nil {
		fake.execReturnsOnCall = make(map[int]struct {
			result1 interface{}
			result2 error
		})
	}
	fake.execReturnsOnCall[i] = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.disconnectMutex.RLock()
	defer fake.disconnectMutex.RUnlock()
	fake.waitUntilRedisNotLoadingMutex.RLock()
	defer fake.waitUntilRedisNotLoadingMutex.RUnlock()
	fake.enableAOFMutex.RLock()
	defer fake.enableAOFMutex.RUnlock()
	fake.lastRDBSaveTimeMutex.RLock()
	defer fake.lastRDBSaveTimeMutex.RUnlock()
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	fake.infoFieldMutex.RLock()
	defer fake.infoFieldMutex.RUnlock()
	fake.globalKeyCountMutex.RLock()
	defer fake.globalKeyCountMutex.RUnlock()
	fake.getConfigMutex.RLock()
	defer fake.getConfigMutex.RUnlock()
	fake.rDBPathMutex.RLock()
	defer fake.rDBPathMutex.RUnlock()
	fake.addressMutex.RLock()
	defer fake.addressMutex.RUnlock()
	fake.waitForNewSaveSinceMutex.RLock()
	defer fake.waitForNewSaveSinceMutex.RUnlock()
	fake.runBGSaveMutex.RLock()
	defer fake.runBGSaveMutex.RUnlock()
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	fake.execMutex.RLock()
	defer fake.execMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ client.Client = new(FakeClient)
